# WeldLoggerPro
JavaFX front-end application for Flowserve Corp
James Kinder
12/8/2020
	This document is meant to describe the software application that I have developed in detail, with visualization and technical explanations.
Project Purpose
	The completed project was a JavaFX data application called Weld Logger Pro that was designed to receive inputs from welders and store them in a database, and then use that data to create business intelligence data reports with descriptive and non-descriptive models to visualize the data and enable business decisions to be made with more visibility than the company had previously at their disposal.  The product at its core was meant to be a replacement system for their physical paper file system that they were using to store this data.
Datasets
	The application interacts with a MS Access database from the company’s quality department for some of the data analytics.  The rest of the data that the application uses will be collected by the software itself through a GUI for the welders to use to input weld logs.  Below is a visualization of the final data structure for the product:
 
	The Reject_Tickets table is a table from the quality database, and is read-only.
Discussion of the application
	The code was written with a View Model Controller architecture.  When the application begins, it launches into the main window:
 
This window has four buttons, each of which navigates the user to a different window.  The application navigation map is as follows:
 
New Weld Job:
 
This form is what a welder will fill out first.  The starred fields are checked for null values before allowing submission.  The create job button will generate a SQL INSERT statement using the values from the text fields and combo boxes.  The cancel button will navigate back to the main page.
Open Weld Jobs:
 
 
The open weld jobs form prompts a welder to enter his/her clock number, whereupon the list view will populate with jobs (using FWO, or factory work order) that are not ended that are associated with that welder clock number.  The welder can then select the job to either add to it a new log, a new part, or to make edits before final submission.  Add log and add part buttons will generate an INSERT statement to execute against the database to associate the entity with the selected weld job.  The “Mo’ Metal” (by specific request from their welding foreman) button will take the selected job and populate the fields in the weld log form with the last entered log for that job, except for No. Out, No. In, Time Out, and Time in.  The reasoning was that for most of the time, the welder will add an additional log to a job when checking in additional weld rod material of the same type, so all of the fields will remain the same except for the above mentioned fields.
Edit Job:
 
This form allows a welder to make changes to jobs that have not yet been closed.  This gives them a change to review their information before submitting it.  From this window the welder can make a change to the weld job information, add and remove associated parts (the tab is identical to the one in the open weld jobs window), edit and delete logs, and submit the job to be ended.  Any changes made to this form will be generated into an UPDATE statement and submitted to the Access database.  Note that in the application there is another identical form I labeled Edit Job (Manager).  That form is identical to this one.  The only difference is that the manager can opt to edit jobs that have been ended, whereas the welder can only select open jobs for editing, and the manager form will navigate back to the dashboard instead of the main form.
Edit Log:
 
The edit log form will pre-populate with data from the selected log from the edit job form.  The user can then make any changes to the log and commit them.  The commit changes button will cause an UPDATE statement to be generated and submitted to the database, and then will navigate the user back to the edit job form.  Again, the manager version of this form is only different in that it will navigate back to the manager edit job form.
All Weld Jobs:
 
The all weld jobs form is simply a form that will display the weld jobs, and the associated parts and logs for the selected job.  A search feature is included for easy data lookup.
Login:
 
The login form will accept a username and password, and then navigate the user to a dashboard depending on the user’s type.  There are three types of users, QA, LEAD, and MANAGER.
QA Check/Foreman Check:
 
The QA and foreman check forms are identical.  They will display any jobs that contain logs that have not been checked by anybody with their user type.  For example, a quality personnel would see all jobs that have outstanding weld logs that have not been checked by quality.  The user can then approve the selected log, removing it from the list.  This fulfills the client’s request for an “electronic signature”.
Dashboard:
 
The dashboard is for the manager user and has four major components.  In the top left corner, there is a clone of the all weld jobs form, but with the additional functionality to edit and delete the jobs.  There is also a fourth table view that is designed to keep visibility up on a key cross-section of data.  The following SELECT statement is used:
SELECT WELDER_CLOCK_NUM, WMS, FORMAT(MAX(DATE_ENTERED), "mm/dd/yyyy") AS MOST_RECENT_DATE
FROM WELD_JOBS AS J INNER JOIN WELD_LOG AS L ON J.JOB_ID = L.JOB_ID
GROUP BY WELDER_CLOCK_NUM, WMS;
Essentially the statement takes every unique combination of welder (by clock number) and WMS number and gives the most recent date that the welder created a log using that WMS number.  The reason for this report is because they need to keep up welder certification continuity.  The WMS number represents a welding process which requires a certification to perform.  To keep the certification from lapsing, the welder must perform that process within a certain time frame.  This table allows the manager look up a welder by their clock number, then see what WMS processes that welder needs to perform soon to keep the certification.
	In the bottom left corner, there is a logistic regression model that takes the weld log and quality department’s reject database as training data, and then plots a logistic regression line as a result to make predictions about the chance of success on future parts.  The data points are all of the associated parts in the database.  The y axis is whether the part was rejected in the reject database, and the x axis (the metric which they told me was most relevant for their purposes) is how many times the part’s associated work order has shown up in the reject database.  As of right now, there is not a lot of training data for the model to work with, and the data is not real, so the regression does not represent a good predictor yet.  The assumption from their experience is that the more times a job is reworked, the less likely the part will pass in a subsequent rework attempt, presumably due to part damage and corruption from welding.  As true data is collected, I expect to see the model predict a higher percent chance of passing with less rejections, and lower chance with more rejections.  As the data accumulates, this tool will be a more powerful analytics tool that will allow the manager to make an educated cost/benefit analysis with the associated risk factor of % chance of failure based on historical results.
	In the top right corner, there is a multi-series line chart which plots First Pass Yield coefficient against the month year to date.  First Pass Yield is a Six Sigma descriptive method which takes a group of data points, and describes them in terms of a descriptive coefficient (ratio of parts that passed inspection on the first attempt vs parts that did not pass).  This coefficient is expressed as a percentage, and is an easily understandable model and key performance indicator for the department.  The chart has multiple series of data to measure FPY so that the manager can more easily find anomalies and weak points in their department.  The FPY is calculated for all the data as the first series, then for all the data that has the rework value set to true (this is a checkbox that the welder can select on the add weld job form, this is essentially a “second pass or greater yield” line).  There are three combo boxes that allow the user to add more FPY lines to the chart by welder, material, and department (parts are welded for large cast, small cast, and forge steel departments).
	Finally, in the bottom right corner we have a pie chart with a combo box that pulls all the rejected jobs and breaks them down based on welder, department, and material.  This is different from the FPY calculation because the FPY calculates its value as a proportion of passed parts to failed parts, whereas the pie chart only tallies up the number of failed parts and compares that count with other counts in the same category.  Basically, the FPY measures the quality efficiency for each data set, whereas the reject breakdown pie chart measures the raw volume of rejected items not adjusted for output.  For example, for the material Stellite 21, the material takes up much more of the pie chart than Stoody, even though it performs much better in FPY.  This allows management to keep a good perspective as to the relative impact of the various categories on quality.  It would be wrong to place the same level of weight on a low performing FPY for a material that is almost never used; much better to spend the resources improving a few percentage points on the high volume materials even if they already have a high FPY.
	I believe that my hypothesis held mostly true.  The FPY and reject breakdown pie charts were both easily understood and came as a welcome surprise to the management at Flowserve when I presented it to them, even without representative data.  The logistic regression model on the other hand was difficult to defend as it did not seem to predict much of anything.  It is hard for me to evaluate at this time, but I believe it is because the data is incomplete and not representative of real world data.  The logistic regression chart had the most extensive use of the reject ticket database, and per my request Flowserve is implementing a change to the table that my software will pull from to facilitate the advanced querying that it performs on the table.  Since that column was newly added (specifically, it was a column that would give the original FWO of the part, which would allow me to relate it to the weld_jobs table), there was no data in that column.  This meant that I had to essentially put poor quality data into that field to test the functionality of the chart.  Bad data means that there really is not going to be a relationship to plot a trend to yet.  It is my hope that with more data good data, the chart will have better training material to plot a better line and give reliable predictions.
Application Testing
I tested on four different levels.  First, I performed unit testing for each section of the code as it was built.  Second, I performed white box integration testing with 100% coverage.  Third, I had a non-technical person perform black box testing without my input or direction.  Lastly, the product is undergoing user testing at Flowserve, but the results have not been reported back to me yet.
Application Files
	This is the directory that I am sending with this submission:
 
Please note that I used JDK 11, JavaFX, as well as the third party library UCanAccess  to allow for Java to interact with a MS Access database.  Also included and essential is the WeldLog.accdb file which includes some dummy data to demonstrate the different data visualizations.  In the real environment, this Access database will be data linked to the quality database, but I have included a static version of the table with the application.  This table has been sufficiently truncated, scrubbed, and falsified, so that the data it contains for the test does not at all resemble any real world data from the company.
